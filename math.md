##### Math 모듈

### 정수 관련 함수
```
import math
```
우선 위와 같이 math 모듈부터 import 해야 한다.

```
math.ceil(3.14) #4
```
위 함수는 '올림' 함수이다. 인자는 하나만 필요로 한다. 결국, 소수점을 올림 하여 정수로 만드는 것이다.

```
math.copysign(3.14, -3) #-3.14
```
두 번째 인자의 부호만 취해 첫 번째 인자에 적용한다. 부호만 취하는 경우는 생각보다 많다.

```
math.fabs(-3.14)    #3.14
```
절댓값을 반환한다.

```
math.factorial(5)   #120
```
팩토리얼 함수인데 팩토리얼은 1부터 인자로 주어진 값까지 모두 곱하는 값을 반환한다. 위의 경우 12345를 계산한 것이다.

```
math.floor(3.78)    #3
```
내림 함수이다. 한 개 인자만 취하며 결국 소수점을 내려 정수로 만든다. 0에 가깝게 내리는 것이 아니라 그냥 작은 값으로 내린다.

```
math.frexp(100) 

```
(0.78125, 7)
입력받은 값이 m * 2**e와 같은 값을 가지는 m과 e를 반환한다. 예를 들어 100을 인자로 넣으면 (0.78125, 7)을 반환하는데 이를 다음과 같이 계산해보면 정확히 100이 나온다.

``` 
0.78125*2**7    #100.0
math.ldexp(0.78125, 7)  #100
```
math.frexp()의 반대인데 m2*e에 각각 대입되어 계산되어 값을 반환받는다. m이 첫 번째 인자이고 e가 두 번째 인자이다.

```
math.gcd(6, 8)  #2
```
두 수의 최대 공약수를 반환한다.

```
math.modf(3.14) #(0.14000000000000012, 3.0)
```
math.modf() 함수는 입력값을 정수와 소수 부분으로 분리해 반환한다. 근데 위의 경우 소수가 0.14가 아니라 유달리 길다. 이는 부동소수점 문제이다. 부동소수점은 10진법 수를 2진법 체계에서 정확히 반영하지 못해 생기는 문제이다. modf()함수는 부동소수점의 값을 그대로 반환한다.

```
math.trunc(3.14)    #3
```
내림 함수이다. math.floor와 비슷해 보이지만 서로 다르다. 아래 예시를 보자.

``` 
math.trunc(-3.14)   #-3
math.floor(-3.14)   #-4
```
trunc()함수는 0으로 향하지만 floor()함수는 무조건 아래로만 향한다.

로그 함수와 제곱
```
math.log(10, 10)    #1
```
math.log(a, b)는 로그 함수이며 b를 밑으로 하는 log a에 대한 로그 값을 리턴한다.

```
math.log1p(x)
```
e를 밑으로 하는 x+1로그

```
math.log2(x)
```
2를 밑으로 하는 x로그

```
math.log10()
```
10을 밑으로 하는 x로그

```
math.pow(3, 2)  #9
```
math.pow(x, y)는 x에 y 승을 계산한 결괏값을 반환한다.

```
math.sqrt(25)   ##결과는 5.0이다.
```
제곱근의 값을 반환한다.

삼각함수
``` 
math.acos(x)    #아크코사인
math.asin(x)    #아크사인
math.atan(x)    #아크탄젠트
math.atan2(y, x)    #y/x 아크탄젠트
math.cos(x) #코사인
math.sin(x) #사인
math.tan(x) #탄젠트
```
각도 변환
```
math.degrees(x)
```
라디안으로 표현된 각도를 60분법 각도로 변환

```
math.radians(x)
```
60분법으로 표현된 각도를 라디안 각도로 변환

상수
```
math.pi ##결과는 3.141592653589793이다. 원주율
math.e  ##결과는 2.718281828459045이다. 자연 상수
math.tau    ##결과는 6.283185307179586이다. 타우
```
